package com.example.onfit.Home

import android.animation.Animator
import android.animation.AnimatorListenerAdapter
import android.animation.ObjectAnimator
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.media.MediaScannerConnection
import android.media.session.MediaSession.Token
import android.graphics.Color
import android.graphics.drawable.ColorDrawable
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.os.Environment
import android.text.Spannable
import android.text.SpannableString
import android.text.style.ForegroundColorSpan
import android.util.Log
import android.view.View
import android.widget.LinearLayout
import android.widget.TextView
import android.widget.Toast
import androidx.activity.result.ActivityResultLauncher
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.ContextCompat
import androidx.fragment.app.Fragment
import androidx.fragment.app.viewModels
import androidx.lifecycle.lifecycleScope
import androidx.navigation.fragment.findNavController
import androidx.recyclerview.widget.LinearLayoutManager
import com.bumptech.glide.Glide
import com.example.onfit.Home.adapter.BestOutfitAdapter
import com.example.onfit.Home.adapter.LatestStyleAdapter
import com.example.onfit.Home.adapter.SimiliarStyleAdapter
import com.example.onfit.Home.model.SimItem
import com.example.onfit.Home.viewmodel.HomeViewModel
import com.example.onfit.KakaoLogin.util.TokenProvider
import com.example.onfit.R
import com.example.onfit.databinding.FragmentHomeBinding
import com.example.onfit.network.RetrofitInstance
import com.example.onfit.OutfitRegister.ApiService
import com.example.onfit.OutfitRegister.RetrofitClient
import com.google.android.material.bottomsheet.BottomSheetDialog
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import okhttp3.MediaType.Companion.toMediaTypeOrNull
import okhttp3.MultipartBody
import okhttp3.RequestBody.Companion.asRequestBody
import java.io.File
import java.io.FileOutputStream
import java.text.SimpleDateFormat
import java.util.*

class HomeFragment : Fragment(R.layout.fragment_home) {

    private var _binding: FragmentHomeBinding? = null
    private val binding get() = _binding!!

    private val viewModel: HomeViewModel by viewModels()
    private var isShortText = false
    private lateinit var pickImageLauncher: ActivityResultLauncher<Intent>
    private var selectedImageUri: Uri? = null

    // ÏÑúÎ≤Ñ Ï∂îÏ≤ú Î°úÎî© Ï†Ñ Ï¥àÍ∏∞ ÌîåÎ†àÏù¥Ïä§ÌôÄÎçî(Î°úÏª¨ Ïù¥ÎØ∏ÏßÄ)
    private val clothSuggestList = listOf(
        R.drawable.cloth1, R.drawable.cloth2, R.drawable.cloth3
    )

    // ÎπÑÏä∑Ìïú ÎÇ† ÏÑπÏÖò Ï¥àÍ∏∞ ÌîåÎ†àÏù¥Ïä§ÌôÄÎçî
    private val similiarClothList = listOf(
        SimItem(R.drawable.simcloth1, null, "Îî± Ï¢ãÏùå"),
        SimItem(R.drawable.simcloth2, null, "Ï°∞Í∏à Ï∂îÏõÄ"),
        SimItem(R.drawable.simcloth3, null, "ÎßéÏù¥ ÎçîÏõÄ")
    )

    // ÎßàÏßÄÎßâ ÌèâÍ∑†Í∏∞Ïò® Ï†ÄÏû• (refresh Ïãú Ïû¨Ìò∏Ï∂úÏóê ÏÇ¨Ïö©)
    private var lastTempAvg: Double? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // Í∞§Îü¨Î¶¨ Launcher
        pickImageLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result ->
            if (result.resultCode == AppCompatActivity.RESULT_OK) {
                selectedImageUri = result.data?.data

                // ÏÑ†ÌÉù Ïù¥ÎØ∏ÏßÄ URI -> Ï∫êÏãú ÌååÏùºÎ°ú Î≥ÄÌôò ÌõÑ ÏóÖÎ°úÎìú
                selectedImageUri?.let { uri ->
                    Log.d("HomeFragment", "ÏÑ†ÌÉùÎêú Ïù¥ÎØ∏ÏßÄ URI: $uri")
                    val cacheFile = uriToCacheFile(requireContext(), uri)
                    Log.d("HomeFragment", "ÌååÏùº Ï°¥Ïû¨ Ïó¨Î∂Ä: ${cacheFile.exists()}")
                    Log.d("HomeFragment", "ÌååÏùº ÌÅ¨Í∏∞: ${cacheFile.length()}")
                    uploadImageToServer(cacheFile)
                }
            }
        }
    }


    // APIÏóê ÌååÏùº ÏóÖÎ°úÎìúÌïòÍ≥† Url Î∞õÏïÑÏò§Í∏∞
    private fun uploadImageToServer(file: File) {
        Log.d("HomeFragment", "ÏóÖÎ°úÎìú Ìï®Ïàò Ïã§ÌñâÎê®: ${file.absolutePath}")
        val token = TokenProvider.getToken(requireContext())
        val header = "Bearer $token"
        val mime = requireContext().contentResolver.getType(Uri.fromFile(file)) ?: "image/jpeg"
        val requestFile = file.asRequestBody(mime.toMediaTypeOrNull())
        val body = MultipartBody.Part.createFormData("image", file.name, requestFile)

        // üìå Ïó¨Í∏∞ÏÑú ÏöîÏ≤≠ Ï†ïÎ≥¥ Î°úÍ∑∏ Ï∞çÍ∏∞
        Log.d("Upload", "file=${file.name}, size=${file.length()}, mime=$mime")
        Log.d("Upload", "url=/items/upload, header=$header, fieldName=image")

        Log.d("UploadREQ",
            "url=http://15.164.35.198:3001/items/upload, " +
                    "auth=${header.take(20)}..., file=${file.name}, size=${file.length()}, mime=image/*"
        )

        viewLifecycleOwner.lifecycleScope.launch(Dispatchers.IO) {
            try {
                val api = RetrofitClient.instance.create(ApiService::class.java)
                val response = api.uploadImage(header, body)

                val rawResponse = response.body()
                Log.d("HomeFragment", "ÏÑúÎ≤Ñ ÏùëÎãµ Î∞îÎîî: $rawResponse")

                withContext(Dispatchers.Main) {
                    if (response.isSuccessful && response.body()?.success == true) {
                        val imageUrl = response.body()!!.data?.imageUrl
                        Log.d("HomeFragment", "Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú ÏÑ±Í≥µ: $imageUrl")

                        // RegisterFragmentÎ°ú URL Ï†ÑÎã¨
                        val bundle = Bundle().apply {
                            putString("selectedImagePath", file.absolutePath)
                            putString("uploadedImageUrl", imageUrl)
                        }
                        findNavController().navigate(
                            R.id.action_homeFragment_to_registerFragment,
                            bundle
                        )
                    } else {
                        val errorMsg = response.errorBody()?.string()
                        Log.e("HomeFragment", "ÏóÖÎ°úÎìú Ïã§Ìå®: code=${response.code()}, error=$errorMsg")
                        Toast.makeText(requireContext(), "ÏóÖÎ°úÎìú Ïã§Ìå®", Toast.LENGTH_SHORT).show()
                    }
                }
            } catch (e: Exception) {
                e.printStackTrace()
                withContext(Dispatchers.Main) {
                    Toast.makeText(requireContext(), "ÏÑúÎ≤Ñ Ïò§Î•ò", Toast.LENGTH_SHORT).show()
                }
            }
        }
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        _binding = FragmentHomeBinding.bind(view)

        val token = TokenProvider.getToken(requireContext())

        // ÎãâÎÑ§ÏûÑ Ï†ÅÏö©
        val nickname = TokenProvider.getNickname(requireContext())
        binding.simTextTv.text = if (nickname.isNotEmpty())
            "ÎπÑÏä∑Ìïú ÎÇ†, ${nickname}ÎãòÏùò Ïä§ÌÉÄÏùº" else "ÎπÑÏä∑Ìïú ÎÇ†, ÌöåÏõêÎãòÏùò Ïä§ÌÉÄÏùº"

        // ====== ÏòµÏ†ÄÎ≤Ñ Îì±Î°ù ======
        observeRecommend()
        viewModel.similarOutfits.observe(viewLifecycleOwner) { items ->
            val hasItems = !items.isNullOrEmpty()
            binding.similarStyleRecyclerView.visibility = if (hasItems) View.VISIBLE else View.GONE
            binding.similarEmptyTv.visibility = if (hasItems) View.GONE else View.VISIBLE
            if (!hasItems) return@observe

            binding.similarStyleRecyclerView.apply {
                adapter = SimiliarStyleAdapter(items)
                layoutManager = LinearLayoutManager(context, LinearLayoutManager.HORIZONTAL, false)
            }
        }

        viewModel.fetchRecentOutfits(token)
        viewModel.recentOutfits.observe(viewLifecycleOwner) { outfits ->
            if (outfits.isNullOrEmpty()) {
                binding.latestStyleEmptyTv.visibility = View.VISIBLE
                binding.latestStyleRecyclerView.visibility = View.GONE
            } else {
                binding.latestStyleEmptyTv.visibility = View.GONE
                binding.latestStyleRecyclerView.visibility = View.VISIBLE
                binding.latestStyleRecyclerView.apply {
                    adapter = LatestStyleAdapter(outfits)
                    layoutManager = LinearLayoutManager(context, LinearLayoutManager.HORIZONTAL, false)
                }
            }
        }

        viewModel.fetchBestOutfits(token)
        viewModel.bestOutfitList.observe(viewLifecycleOwner) { outfitList ->
            Log.d("BestOutfit", "bestOutfit size=${outfitList.size}")
            if (outfitList.isNullOrEmpty()) {
                binding.bestOutfitEmptyTv.visibility = View.VISIBLE
                binding.bestoutfitRecycleView.visibility = View.GONE
            } else {
                binding.bestOutfitEmptyTv.visibility = View.GONE
                binding.bestoutfitRecycleView.visibility = View.VISIBLE
                binding.bestoutfitRecycleView.apply {
                    adapter = BestOutfitAdapter(outfitList)
                    layoutManager = LinearLayoutManager(context, LinearLayoutManager.HORIZONTAL, false)
                }
            }
        }

        viewModel.fetchDate()
        viewModel.dateLiveData.observe(viewLifecycleOwner) {
            updateCombinedInfo(it, TokenProvider.getLocation(requireContext()))
        }

        viewModel.errorLiveData.observe(viewLifecycleOwner) {
            if (!it.isNullOrBlank()) Toast.makeText(requireContext(), it, Toast.LENGTH_SHORT).show()
        }
        // ====== /ÏòµÏ†ÄÎ≤Ñ Îì±Î°ù ======

        // ÎπÑÏä∑Ìïú ÎÇ† ÏÑπÏÖò(Ï¥àÍ∏∞ ÌîåÎ†àÏù¥Ïä§ÌôÄÎçî)
        binding.similarStyleRecyclerView.apply {
            adapter = SimiliarStyleAdapter(similiarClothList)
            layoutManager = LinearLayoutManager(context, LinearLayoutManager.HORIZONTAL, false)
        }

        // Ï¥àÍ∏∞ Ï∂îÏ≤ú Ïù¥ÎØ∏ÏßÄ(Î°úÏª¨ ÌîåÎ†àÏù¥Ïä§ÌôÄÎçî)
        setRandomImages()

        // ÏÉàÎ°úÍ≥†Ïπ® ÏÑúÎ≤Ñ Ï∂îÏ≤ú Ïû¨Ìò∏Ï∂ú
        binding.refreshIcon.setOnClickListener {
            val tokenNow = TokenProvider.getToken(requireContext())
            val temp = lastTempAvg
            if (tokenNow.isBlank() || temp == null) {
                Toast.makeText(requireContext(), "ÎÇ†Ïî® Ï†ïÎ≥¥ Î°úÎî© ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥ Ï£ºÏÑ∏Ïöî.", Toast.LENGTH_SHORT).show()
                return@setOnClickListener
            }
            spinRefreshIcon()
            viewModel.fetchRecommendItems(tokenNow, temp)
        }

        // ÏúÑÏπò Î≥ÄÍ≤Ω
        binding.locationBtn.setOnClickListener {
            val action = HomeFragmentDirections.actionHomeFragmentToLocationSettingFragment(true)
            findNavController().navigate(action)
        }

        // ÎÇ¥Ïùº ÎÇ†Ïî® Î≤ÑÌäº
        binding.weatherBtn.setOnClickListener { fetchTomorrowWeather() }

        // Îì±Î°ùÌïòÍ∏∞ Î≤ÑÌäº
        binding.homeRegisterBtn.setOnClickListener { showBottomSheet() }
    }

    override fun onResume() {
        super.onResume()
        fetchCurrentWeather()
    }

    private fun fetchCurrentWeather() {
        val token = TokenProvider.getToken(requireContext())
        val location = TokenProvider.getLocation(requireContext())
        lifecycleScope.launch {
            try {
                val response = RetrofitInstance.api.getCurrentWeather("Bearer $token")
                if (response.isSuccessful) {
                    val weather = response.body()?.result?.weather
                    val tempMax = weather?.tempMax?.toInt() ?: 0
                    val tempMin = weather?.tempMin?.toInt() ?: 0
                    val precipitation = weather?.precipitation?.toInt() ?: 0
                    val tempAvg = weather?.tempAvg ?: 0.0
                    val status = weather?.status ?: "Unknown"

                    // ÎßàÏßÄÎßâ ÌèâÍ∑†Í∏∞Ïò® Ï†ÄÏû• (refreshÏóêÏÑú ÏÇ¨Ïö©)
                    lastTempAvg = tempAvg

                    updateCombinedInfo(getTodayDateString(), location)
                    binding.weatherInformTv.text = "ÏµúÍ≥† ${tempMax}¬∞C ¬∑ ÏµúÏ†Ä ${tempMin}¬∞C ¬∑ Í∞ïÏàòÌôïÎ•† ${precipitation}%"
                    binding.tempTv.text = "${tempAvg.toInt()}¬∞C"

                    val fullText = "Ïò§Îäò ${tempAvg.toInt()}¬∞C, Îî± ÎßûÎäî Ïä§ÌÉÄÏùºÏù¥ÏóêÏöî!"
                    val targetText = "${tempAvg.toInt()}¬∞C"
                    val spannable = SpannableString(fullText)
                    val startIndex = fullText.indexOf(targetText)
                    val endIndex = startIndex + targetText.length
                    val color = ContextCompat.getColor(requireContext(), R.color.basic_blue)
                    spannable.setSpan(ForegroundColorSpan(color), startIndex, endIndex, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)
                    binding.weatherTitle.text = spannable

                    updateWeatherImages(status)

                    // ÌèâÍ∑†Í∏∞Ïò®ÏúºÎ°ú Ï∂îÏ≤ú + similar-weather Ìò∏Ï∂ú
                    weather?.tempAvg?.let {
                        requestRecommendForTemp(it)
                        viewModel.fetchSimilarWeather(token, it)
                    }
                } else {
                    binding.weatherInformTv.text = "ÎÇ†Ïî® Ï†ïÎ≥¥Î•º Í∞ÄÏ†∏Ïò§ÏßÄ Î™ªÌñàÏäµÎãàÎã§."
                    binding.tempTv.text = ""
                }
            } catch (e: Exception) {
                binding.weatherInformTv.text = "ÎÇ†Ïî® Ïò§Î•ò: ${e.message}"
                binding.tempTv.text = ""
            }
        }
    }

    private fun fetchTomorrowWeather() {
        val token = TokenProvider.getToken(requireContext())
        val location = TokenProvider.getLocation(requireContext())
        lifecycleScope.launch {
            try {
                val response = RetrofitInstance.api.getTomorrowWeather("Bearer $token")
                if (response.isSuccessful) {
                    val weather = response.body()?.result?.weather
                    val tempMax = weather?.tempMax?.toInt() ?: 0
                    val tempMin = weather?.tempMin?.toInt() ?: 0
                    val precipitation = weather?.precipitation?.toInt() ?: 0
                    val tempAvg = weather?.tempAvg ?: 0.0
                    val status = weather?.status ?: "Unknown"

                    // ÎÇ¥Ïùº ÌèâÍ∑†Í∏∞Ïò®ÎèÑ Ï†ÄÏû•
                    lastTempAvg = tempAvg

                    updateCombinedInfo(getTomorrowDateString(), location)
                    binding.weatherInformTv.text = "ÏµúÍ≥† ${tempMax}¬∞C ¬∑ ÏµúÏ†Ä ${tempMin}¬∞C ¬∑ Í∞ïÏàòÌôïÎ•† ${precipitation}%"
                    binding.tempTv.text = "${tempAvg.toInt()}¬∞C"

                    val fullText = "ÎÇ¥Ïùº ${tempAvg.toInt()}¬∞C, Ïñ¥Îñ§ Ïä§ÌÉÄÏùºÏùºÍπåÏöî?"
                    val targetText = "${tempAvg.toInt()}¬∞C"
                    val spannable = SpannableString(fullText)
                    val startIndex = fullText.indexOf(targetText)
                    val endIndex = startIndex + targetText.length
                    val color = ContextCompat.getColor(requireContext(), R.color.basic_blue)
                    spannable.setSpan(ForegroundColorSpan(color), startIndex, endIndex, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE)
                    binding.weatherTitle.text = spannable

                    updateWeatherImages(status)

                    weather?.tempAvg?.let {
                        requestRecommendForTemp(it)
                        viewModel.fetchSimilarWeather(token, it)
                    }
                } else {
                    binding.weatherInformTv.text = "ÎÇ¥Ïùº ÎÇ†Ïî® Ï†ïÎ≥¥Î•º Í∞ÄÏ†∏Ïò§ÏßÄ Î™ªÌñàÏäµÎãàÎã§."
                    binding.tempTv.text = ""
                }
            } catch (e: Exception) {
                binding.weatherInformTv.text = "ÎÇ¥Ïùº ÎÇ†Ïî® Ïò§Î•ò: ${e.message}"
                binding.tempTv.text = ""
            }
        }
    }

    // ====== Ï∂îÏ≤ú Ïó∞Îèô ======
    private fun observeRecommend() {
        viewModel.recommendItems.observe(viewLifecycleOwner) { items ->
            val hasItems = !items.isNullOrEmpty()
            binding.suggestedContainer.visibility = if (hasItems) View.VISIBLE else View.GONE
            binding.suggestedEmptyTv.visibility = if (hasItems) View.GONE else View.VISIBLE
            if (!hasItems) return@observe

            // ÏÑúÎ≤Ñ Ï∂îÏ≤úÏùÑ Í∑∏ÎåÄÎ°ú 3Í∞úÍπåÏßÄ Î∞òÏòÅ (ÏÑúÎ≤ÑÍ∞Ä ÎûúÎç§ Ï†úÍ≥µÌïúÎã§Í≥† Í∞ÄÏ†ï)
            val views = listOf(binding.suggestedCloth1Iv, binding.suggestedCloth2Iv, binding.suggestedCloth3Iv)
            for (i in views.indices) {
                val iv = views[i]
                val item = items.getOrNull(i)
                if (item?.image != null) {
                    Glide.with(iv)
                        .load(item.image)
                        .placeholder(ColorDrawable(Color.parseColor("#EEEEEE")))
                        .error(ColorDrawable(Color.parseColor("#DDDDDD")))
                        .into(iv)
                } else {
                    Glide.with(iv)
                        .load(null as String?)
                        .placeholder(ColorDrawable(Color.parseColor("#EEEEEE")))
                        .error(ColorDrawable(Color.parseColor("#DDDDDD")))
                        .into(iv)
                }
            }
        }

        viewModel.diurnalMsg.observe(viewLifecycleOwner) { msg ->
            if (!msg.isNullOrBlank()) binding.subTv.text = msg
        }
    }

    private fun requestRecommendForTemp(tempAvg: Double) {
        val token = TokenProvider.getToken(requireContext())
        if (token.isBlank()) {
            Toast.makeText(requireContext(), "Î°úÍ∑∏Ïù∏Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§.", Toast.LENGTH_SHORT).show()
            return
        }
        viewModel.fetchRecommendItems(token, tempAvg)
    }
    // ====== /Ï∂îÏ≤ú Ïó∞Îèô ======

    private fun updateWeatherImages(status: String) {
        when (status) {
            "Storm" -> { binding.sunIv.setImageResource(R.drawable.weather_storm); binding.sunnyIv.setImageResource(R.drawable.weather_storm_bg) }
            "Snow" -> { binding.sunIv.setImageResource(R.drawable.weather_snow); binding.sunnyIv.setImageResource(R.drawable.weather_snow_bg) }
            "Rain" -> { binding.sunIv.setImageResource(R.drawable.weather_rain); binding.sunnyIv.setImageResource(R.drawable.weather_rain_bg) }
            "Fog" -> { binding.sunIv.setImageResource(R.drawable.weather_fog); binding.sunnyIv.setImageResource(R.drawable.weather_fog_bg) }
            "CloudFew" -> { binding.sunIv.setImageResource(R.drawable.weather_cloudfew); binding.sunnyIv.setImageResource(R.drawable.weather_cloudfew_bg) }
            "CloudMany" -> { binding.sunIv.setImageResource(R.drawable.weather_manycloud); binding.sunnyIv.setImageResource(R.drawable.weather_manycloud_bg) }
            "CloudBroken" -> { binding.sunIv.setImageResource(R.drawable.weather_brokencloud); binding.sunnyIv.setImageResource(R.drawable.weather_brokencloud_bg) }
            "Sun" -> { binding.sunIv.setImageResource(R.drawable.weather_sun); binding.sunnyIv.setImageResource(R.drawable.weather_sun_bg) }
            else -> { binding.sunIv.setImageResource(R.drawable.weather_sun); binding.sunnyIv.setImageResource(R.drawable.weather_sun_bg) }
        }
    }

    private fun updateCombinedInfo(date: String, location: String) {
        binding.combinedInfoTv.text = "$date $location ÎÇ†Ïî®"
    }

    private fun getTodayDateString(): String {
        val calendar = Calendar.getInstance()
        val format = SimpleDateFormat("MÏõî dÏùº", Locale.KOREA)
        return format.format(calendar.time)
    }

    private fun getTomorrowDateString(): String {
        val calendar = Calendar.getInstance()
        calendar.add(Calendar.DATE, 1)
        val format = SimpleDateFormat("MÏõî dÏùº", Locale.KOREA)
        return format.format(calendar.time)
    }

    // Ï¥àÍ∏∞ ÌîåÎ†àÏù¥Ïä§ÌôÄÎçî(Î°úÏª¨)Îßå ÏÖãÏóÖ
    private fun setRandomImages() {
        val mix = clothSuggestList.shuffled().take(3)
        binding.suggestedCloth1Iv.setImageResource(mix[0])
        binding.suggestedCloth2Iv.setImageResource(mix[1])
        binding.suggestedCloth3Iv.setImageResource(mix[2])
    }

    // ÏÉàÎ°úÍ≥†Ïπ® ÏïÑÏù¥ÏΩò ÌöåÏ†Ñ Ïï†ÎãàÎ©îÏù¥ÏÖò (UXÏö©)
    private fun spinRefreshIcon() {
        ObjectAnimator.ofFloat(binding.refreshIcon, "rotation", 0f, 360f).apply {
            duration = 400
            start()
        }
    }

    private fun showBottomSheet() {
        val view = layoutInflater.inflate(R.layout.bottom_sheet_dialog, null)
        val dialog = BottomSheetDialog(requireContext())
        dialog.setContentView(view)
        view.findViewById<LinearLayout>(R.id.camera_btn).setOnClickListener {
            // Ïπ¥Î©îÎùº ‚Üí ÌòÑÏû¨Îäî Îì±Î°ù ÌôîÎ©¥ÏúºÎ°ú Ïù¥ÎèôÎßå
            findNavController().navigate(R.id.action_homeFragment_to_registerFragment)
            dialog.dismiss()
        }
        view.findViewById<LinearLayout>(R.id.gallery_btn).setOnClickListener {
            // Í∂åÌïú ÌôïÏù∏ ‚Üí Pictures Ïä§Ï∫î ‚Üí Í∞§Îü¨Î¶¨ Ïó¥Í∏∞
            ensurePhotoPermission { rescanPicturesAndOpenGallery() }
            dialog.dismiss()
        }
        dialog.show()
    }

    private fun animateTextChange(textView: TextView, newText: String) {
        val fadeOut = ObjectAnimator.ofFloat(textView, "alpha", 1f, 0f)
        val fadeIn = ObjectAnimator.ofFloat(textView, "alpha", 0f, 1f)
        fadeOut.duration = 150; fadeIn.duration = 150
        fadeOut.addListener(object : AnimatorListenerAdapter() {
            override fun onAnimationEnd(animation: Animator) {
                textView.text = newText; fadeIn.start()
            }
        })
        fadeOut.start()
    }

    private fun uriToCacheFile(context: Context, uri: Uri): File {
        val inputStream = context.contentResolver.openInputStream(uri)
        val file = File(context.cacheDir, "selected_outfit.png")
        val outputStream = FileOutputStream(file)
        inputStream?.use { input ->
            outputStream.use { output -> input.copyTo(output) }
        }
        return file
    }


    // 1) Í∂åÌïú Ï≤¥ÌÅ¨ (API33+ READ_MEDIA_IMAGES / Ïù¥Ìïò READ_EXTERNAL_STORAGE)
    private fun ensurePhotoPermission(onGranted: () -> Unit) {
        val perm = if (Build.VERSION.SDK_INT >= 33)
            android.Manifest.permission.READ_MEDIA_IMAGES
        else
            android.Manifest.permission.READ_EXTERNAL_STORAGE

        if (ContextCompat.checkSelfPermission(requireContext(), perm) ==
            PackageManager.PERMISSION_GRANTED) {
            onGranted()
        } else {
            requestPermissionLauncher.launch(perm)
        }
    }

    private val requestPermissionLauncher =
        registerForActivityResult(ActivityResultContracts.RequestPermission()) { granted ->
            if (granted) {
                // Í∂åÌïúÏù¥ Î∞©Í∏à ÌóàÏö©ÎêòÎ©¥ Ïä§Ï∫î ÌõÑ Í∞§Îü¨Î¶¨ Ïó¥Í∏∞
                rescanPicturesAndOpenGallery()
            } else {
                Toast.makeText(requireContext(), "ÏÇ¨ÏßÑ Ï†ëÍ∑º Í∂åÌïúÏù¥ ÌïÑÏöîÌï¥Ïöî", Toast.LENGTH_SHORT).show()
            }
        }

    // 2) Pictures Ìè¥Îçî Ïä§Ï∫î ÌõÑ Í∞§Îü¨Î¶¨ Ïó¥Í∏∞
    private fun rescanPicturesAndOpenGallery() {
        // ÏóêÎÆ¨Î†àÏù¥ÌÑ∞/Device ExplorerÎ°ú ÎÑ£ÏùÄ ÌååÏùºÏùÑ Ïù∏Îç±Ïã±
        val picturesPath = Environment.getExternalStoragePublicDirectory(
            Environment.DIRECTORY_PICTURES
        ).absolutePath

        MediaScannerConnection.scanFile(
            requireContext(),
            arrayOf(picturesPath),
            null
        ) { _, _ ->
            // Ïä§Ï∫î ÏΩúÎ∞±ÏóêÏÑú Í∞§Îü¨Î¶¨ Ïó¥Í∏∞ (Ïä§Ï∫î ÏôÑÎ£å ÌõÑ)
            requireActivity().runOnUiThread { openGallery() }
        }
    }

    // gallery_btn ÌÅ¥Î¶≠ Ïãú Ïã§Ìñâ

    private fun openGallery() {
        val intent = Intent(Intent.ACTION_PICK).apply { type = "image/*" }
        pickImageLauncher.launch(intent)
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }
}
